# obstacle-avoiding-robot-q-learning
in this project i created an obstacle avoiding robot using the  q learnig algorithm which is based on learning from trial and error and giving  rewards for the right move  and penalties for the wrong move ,the same way humans learn

PROBLEM
the object is to teach the robot to learn how to avoid obstacles 
after a certain number of episodes and from this dataset it 
can then the optimal action to take .

MATERIALS USED

1.ultrasonic sensor
The SEN136B5B is an ultrasonic range finder from Seeedstudio. 
It detects the distance of the closest object in front of the 
sensor (from 3 cm up to 400 cm). It works by sending out a burst
of ultrasound and listening for the echo when it bounces off of an
 object. It pings the obstacles with ultrasound. The Arduino board 
sends a short pulse to trigger the detection, then listens for a 
pulse on the same pin using the pulseIn() function. The duration
 of this second pulse is equal to the time taken by the ultrasound 
to travel to the object and back to the sensor. 
Using the speed of sound, this time can be converted to distance.
[source :https://docs.arduino.cc/built-in-examples/sensors/Ping]

2.L298 H bridge motor driver 

This module is based on the very popular L298 Double H-Bridge integrated circuit driver.
The circuit will allow you to easily and independently control two motors up to 2A each in both directions.

It is ideal for robotics applications and well suited for connection to a microcontroller requiring only a few control lines per motor. 
It can also be interfaced with simple manual switches, TTL logic gates, relays, etc.

Characteristic

     Motor power supply: 7 to 24 VDC
     Control logic: Standard TTL level logic
     Output Power: Up to 2A, 25W each
     Enable and Control Direction Pins
     Radiator for IC
     LED power indicator
     4 Direction LED Indicators

3.powerbank

4.jumper wires

5.dc motors

6. Two wheel robot car chasis

7.arduino uno

Code Explanation

int ACTIONS = [0,1,2,3]

//deines the actions the robot must perform which are forward  backward left and stop
//with 0 forward 1 backward 2 left and 3 right

int NEXT_STATE;
int STATE = 0;
NEXT_STATE = STATE+1;

//this is the state that the robot moves into after performing the first action 
//the initial state of the robot in the beginning of a episode is survive 

float Q[N_STATES][NUMBER_OF_ACTIONS] = {{0.0,0.0,0.0,0.0}, 
                                        {0.0,0.0,0.0,0.0},  
                                        {0.0,0.0,0.0,0.0},   
                                        {0.0,0.0,0.0,0.0},   
                                        {0.0,0.0,0.0,0.0},  
                                        {0.0,0.0,0.0,0.0},
                                        {0.0,0.0,0.0,0.0},
                                        {0.0,0.0,0.0,0.0},
                                        {0.0,0.0,0.0,0.0},
                                        {0.0,0.0,0.0,0.0}};
//
